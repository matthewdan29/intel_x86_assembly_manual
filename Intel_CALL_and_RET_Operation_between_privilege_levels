When making a call to a more privileged protection level, the processor takes these steps: 

1) Perfroms a access rights check (privilege check)

2) Temporarily saves (internally) the current contents of the SS, ESP, CS, and EIP registers. 

3) Loads the segment selector and stack pointer for the new stack (that is, the stack for the privilege level being called) from the TSS into the SS and ESP registers and switches to the new stack. 

4) Pushes the temporarily saved SS and ESP values for the calling procedure's stack onto the new stack. 

5) Copies the parameters from the calling procedure's stack to the new stack. A value in the call gate descriptor determines how many parameters to copy to the new stack. 

6) Pushes the tempararily saved CS and EIP values for the calling procedure to the new stack.
		A) If shadow stack is enabled at the privilege level of the calling procedure, then the processor temporarily saves the SSP of the calling procedure internally. If the calling procedure is at privilege level 3, the SSP of the calling procedure is also saved into the IA32_PL3_SSP MSR. 

		B) If shadow stack is enabled at the privilege level of the called procedure, then the SSP for the called procedure is obtaiuned from one of the MSRs list below, depending on the target privilege level. The SSP obtained is then verified to ensure it points to a valid supervisor shaw stack that is not currently active by verifying a supervisor shadow stack token by making it busy.
			1) IA32_PL2_SSP if transitioning to ring 2

			2) IA32_PL1_SSP if transition to ring 1

			3) IA32_PL0SSP	if transistioning to ring 0 

		C) IF shadow stack is enabled at the privilege level of the called procedure and trhe calling procedure was not at privilege level 3, then the processor pushes the temporarily saved CS, LIP (CS.base + EIP), and SSP of the calling procedure to the new shadow stack

7)Loads the segment selector for the new code segment and the new instruction pointer from the call gate into the CS and EIP registers, repectively 

8) Begins execution of the called procedere at the new privilege level.

When executing a return from the privilege procedure, the processor performs these actions: 

1) Performs a privilege check 

2) Restores the CS and EIP registers to their values level prior to the call

	A) If shadow stack is enabled at the current privilege level: 

		1) Causes a control protection exception (#CP(FAR-RET/IRET)) if SSP is not aligned to 8 bytes. 

		2) If the privielge level of the procedure being returned to is less than 3 (returning to supervisor mode): 	

			A) Compares the values on shadow stack at address SSP+8 (the LIP) and SSP+16 (the CS) to the CS and (CS.base + EIP) popped from the stack and causes a control protection exception (#CP(FAR-RET/IRET)) if they do not match

			B) Temporarily saves the top-of-stack value (The SSP of the procedure being returned to) internally

		3) If a busy supervisor shadow stack token is present at address SSP+24, then marks the token free using operations 

		4) If the privilege level of the procedure being returned to is less than 3 (returning to supervisor mode),  restores the SSP register from the internally saved value.

		5) If the privilege level of the procedure being returned to is 3 (returning to user mode) and shadow stack is enabled at privilege level 3, then restores the SSP register with values of IA32_PL3_SSP MSF (systemcall)

3) If the RET instruction has an optional n argument, increments the stack pointer by the number of bytes specified with the n operand to release parameters from the stack. If the call gate descriptor specifies that one or more parameters be copied from one stack to the other, a RET n instruction must be used to release the parameters from both stacks. Here, the n operand specifies the number of bytes occupied on each stack by the parameters. On a return, the processor increments ESP by mn for each stack to step over (effectively remove) these parameters from the stacks. 

4) Restores the SS and ESP registers to their values prior to the call, which causes a switch back to the stack of the calling procedure. 

5) If the RET instrction has an optional n argument, increments the stack pointer by the number of bytes specified with the n operand to release parameters from the stack 

6) Resumes execution of the calling procedure 
